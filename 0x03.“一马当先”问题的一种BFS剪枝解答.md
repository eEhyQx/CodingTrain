# “一马当先”问题的一种BFS剪枝解答
[知乎文章](https://www.zhihu.com/people/zhang-qi-xuan-79/posts)
## 写在最前面 
最近在PythonTip的题库中练习时看到这样一道题：

> “一马当先”  
>          下过象棋的人都知道，马只能走'日'字形（包括旋转90°的日），现在想象一下，给你一个n行m列网格棋盘， 棋盘的左下角有一匹马，请你计算至少需要几步可以将它移动到棋盘的右上角，若无法走到，则输出-1. 如n=1，m=2,则至少需要1步；若n=1，m=3,则输出-1。  

这道题让我想起了高中时自己参加丘奖时解决“平面魔方”问题时所采取的一种基于广度优先搜索的剪枝策略，相对传统的BFS能极大程度减少储存数据量。
**附文**
* [(en) Research into the Group of 2D magic cube](https://github.com/eEhyQx/WeCreate/blob/master/0x02.%5Ben%5DResearch%20into%202D%20Magic%20Cube.pdf)
* [(cn) 对平面魔方群及其Cayley图直径的研究](https://github.com/eEhyQx/WeCreate/blob/master/0x02.%5Bcn%5D%E5%AF%B9%E5%B9%B3%E9%9D%A2%E9%AD%94%E6%96%B9%E7%BE%A4%E5%8F%8A%E5%85%B6Cayley%E5%9B%BE%E7%9B%B4%E5%BE%84%E7%9A%84%E7%A0%94%E7%A9%B6.pdf)

联合作者：贾子涵(ZJU) , 项羽铭(ZJU)

由于本人还未正式升入大学，学识尚浅，并不知晓这种剪枝方法是否早已为人所熟知，如若觉得“有辱智商”还望海涵。
下文我将以“一马当先”问题为依托介绍这种基于BFS的剪枝策略。

## 摘要
本文在广度优先搜索(BFS)的基础上引入了一种较为直接、有效且具有普适意义的剪枝方法，进而得到了一种占用内存少的“一马当先”最优解算法。
**关键词：BFS        剪枝       “一马当先”最优解**
## 算法的实现
话不多说先给代码：
```m,n=int(input("输入m行")),int(input("输入n列"))
def move(loc,i):
    locs=loc[:]
    if i==1:
        locs[0],locs[1]=loc[0]-2,loc[1]+1
    elif i==2:
        locs[0],locs[1]=loc[0]-1,loc[1]+2
    elif i==3:
        locs[0],locs[1]=loc[0]+1,loc[1]+2
    elif i==4:
        locs[0],locs[1]=loc[0]+2,loc[1]+1
    elif i==5:
        locs[0],locs[1]=loc[0]+2,loc[1]-1
    elif i==6:
        locs[0],locs[1]=loc[0]+1,loc[1]-2
    elif i==7:
        locs[0],locs[1]=loc[0]-1,loc[1]-2
    elif i==8:
        locs[0],locs[1]=loc[0]-2,loc[1]-1
    return locs
def solve():
    global m,n
    temp=[[],[[0,0]],[]]
    t=1
    f=True
    while f:
        f=False
        for loc in temp[1]:
            for i in range(1,9):
                if move(loc,i)==[m,n]:
                    return t
                elif move(loc,i)[0]>=0 and move(loc,i)[1]>=0 and move(loc,i)[0]<=m and move(loc,i)[1]<=n and not(move(loc,i) in temp[0] or move(loc,i) in temp[1] or move(loc,i) in temp[2]):
                    temp[2].append(move(loc,i))
                    f=True
        t+=1
        del temp[0]
        temp.append([])
    return -1
print(solve())
```
## 元素定义
- [i,j]：记[0,0]为左下角的坐标(即起点坐标)，[m,n]为右下角的坐标(即终点位置，其中mn由程序给定)，如此我们便可用一组整数[i,j]来表示棋盘上任意一点，即该点的坐标(其中0<=i<=m,0<=j<=n)。
- move(loc,i): 函数move用来对在位置loc上的棋子进行移动，返回值为移动后的新位置。不同的i值表示不同的移动的策略，这里采用枚举的方法给出了所有符合规则的移动策略。
* solve():函数solve实际上是主程序，用于对最优解的求解，内部元素有：
	1. temp：用来存储不同层的坐标，其中temp[0]表示上一层，temp[1]表示当前层，temp[2]表示下一层。
	2. f：逻辑型值，用来记录是否有新的坐标被丢入temp[2]中。
	3. t：用于记录层数。
## 流程介绍
考虑到我们很难保证每一步都恰好走最优路线，最优路线也不一定只有一条。所以与其在走法上对期望进行预判，不如从起点开始构造树图，看看哪一枝干能最先生成终点情况。所以理论上，我们只要遍历每一层的每一个分支内的每一个元素，我们就能解决这样的问题，这也是最基本的暴力BFS。

但随着m,n的增大，分支数目的增长速度也是惊人的，这也是为什么解题报告中许多人反映出现超时问题的原因。由于之前接触过类似问题，对它的数量级我是有些预判的，这回暴力大概出不了奇迹。除非从数学角度下功夫思索(如：采取矩阵方法)，否则剪枝看起来不可或缺。

**定理** 	由某一层的某一个节点产生的分支，只可能出现在以下三层：1. 该节点所在层；2.该节点上一层；3.该节点下一层.
**证明**         由节点树的连结方式不难证明，每一层只与它的相邻层连接。由于
我们采用的是广度优先搜索，所以并不会出现节点所在层数被延后的情况，故结论成立。

事实上我们可以用图论的知识来证明这一点，但由于我采用的的编辑器不支持数学公式的编辑，故只能以文字证明。相关数学证明可以参考我的丘奖论文。
不难想到的是，我们实际上只要在这三层内进行比对，进行重复剪枝，其余层数的数据实际上我们可以删除。而当某一层的节点不再产生新的节点时，实际上这棵树上所有的节点都已经被遍历了。

回到“一马当先”问题上来， 在以上基础上我们设想以下流程：
1. 创建一个序列temp=`[[],[[0,0]],[]]`,分别表示上一层、当前层、下一层；
2. 初始化`t=1，f=True`；
3. 若f为True进入以下流程，否则输出-1；
4. 令`f=False`，依次遍历temp[1]里的每一个坐标，对每一个坐标采取全部8种移动方式，若移动到了[m,n]则输出层数t；
5. 若移动后仍在棋盘内且不存在temp里任何一层中，则将这个坐标加入到`temp[2]`中，且令`f=True`；
6. 遍历完成后，`del temp[0]`以控制数据量，这个操作同时使temp[1]顶替temp[0]，temp[2]顶替temp[1]，然后使用`append`方法插入一个新的空序列作为temp[2]，`t+=1`；
7. 回到第三步并重复。

如此，我们便有了前文中给出的代码。

## 结语
解题报告中很多网友都试图采用简单的数学方法去思考这个问题，但是大多数由于“未考虑回走”等原因失败了；有的则是借A*等算法得到了非最优策略；还有一些则是遇到了超时问题。我不知道检测器采用的是哪几对mn，直接采用暴力BFS会不会超时，但相较这些，这样一种简单而又有效的剪枝可以更好而更快的解决问题。
本文撰于2018年暑假，刚收到大学通知书，故鄙人学识尚浅，如有疏漏还望批评指正。

           



